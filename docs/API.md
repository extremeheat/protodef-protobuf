# API Reference

This document provides a detailed API for the `protodef-protobuf` library.

---

## Transpiler (`protodef-protobuf/transpiler`)

The transpiler module contains functions for converting `.proto` schemas into `protodef`-compatible JSON.

### `transpileProtobufAST(ast)`

Converts a single, parsed Protocol Buffers AST into a `protodef` JSON schema.

- **`ast`** `<Object>`: The Abstract Syntax Tree object generated by the `protocol-buffers-schema` package.
- **Returns** `<Object>`: A `protodef`-compatible JSON schema object containing the definitions for all messages and enums found in the AST.

---

### `mergeAsts(asts)`

Merges multiple ASTs into a single AST. This is the recommended way to handle `.proto` files that use `extensions`.

- **`asts`** `<Array>`: An array of AST objects from `protocol-buffers-schema`.
- **Returns** `<Object>`: A single, unified AST object containing all messages, enums, and `extend` blocks from the input ASTs.

**Example:**
```javascript
const baseAst = schemaParser.parse(baseProtoContent);
const extAst = schemaParser.parse(extensionProtoContent);
const mergedAst = mergeAsts([baseAst, extAst]);
const generatedSchema = transpileProtobufAST(mergedAst); // Now contains extended fields
```

---

## Custom Protodef Types (`protodef-protobuf/compiler`)

This module contains the custom parametrizable compiler types that teach protodef how to handle the Protobuf wire format.

### `protobuf_container`

This is the core runtime for serializing and deserializing the fields within a single Protobuf message. It correctly handles the tag-based, order-independent wire format.

> **Note:** You will typically not use this type directly in your protocol definitions. The transpiler automatically generates it for each message it processes.

---

### `protobuf_message`

This is a container type used to frame a complete Protobuf message, typically with a length prefix. This is essential for embedding Protobuf messages in a stream or alongside other data.

**Usage:**  
`['protobuf_message', options]`

#### `options` `<Object>`:

- `type` `<String>`: The name of the `protobuf_container` type to be encapsulated.
- `lengthType` `<String>` (optional): The protodef type to use for reading and writing the length prefix from the stream (e.g., `'varint'`, `'u16'`).
- `length` `<String>` (optional): The path to a variable in the context that contains the length of the message. This is used when the length is defined elsewhere in the protocol.

You must provide either `lengthType` or `length`.

---

#### Example 1: Self-contained, length-prefixed packet

```javascript
const myProtocol = {
  packet: ['protobuf_message', {
    lengthType: 'varint',
    type: 'my_package_MyMessage'
  }]
};
```

#### Example 2: Length provided by another field

```javascript
const myProtocol = {
  packet: ['container', [
    { name: 'payloadLength', type: 'u16' },
    { name: 'payload', type: ['protobuf_message', {
      length: 'payloadLength', // Use the value of the field we just read
      type: 'my_package_MyMessage'
    }]}
  ]]
};
```
